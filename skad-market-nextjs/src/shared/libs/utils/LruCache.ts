/**
 * Класс LruCache реализует механизм кэширования с вытеснением наименее часто используемых элементов (Least Recently Used, LRU).
 * Он предназначен для хранения ограниченного количества элементов и автоматического удаления наиболее редко используемых элементов,
 * когда количество хранимых элементов превышает установленный предел размера кэша.
 */
export class LruCache {
  /**
   * Хранилище для элементов кэша. Использует Map для сохранения порядка добавления.
   * @private
   * @type {Map<string, boolean>}
   */
  private cache: Map<string, boolean>

  /**
   * Максимальный размер кэша. Когда количество элементов в кэше достигает этого значения,
   * самый ранний использованный элемент будет удален при добавлении нового.
   * @private
   * @type {number}
   */
  private readonly maxSize: number

  /**
   * Создает экземпляр LruCache.
   * @param {number} maxSize - Максимальное количество элементов, которое может хранить кэш.
   */
  constructor(maxSize: number = 500) {
    this.maxSize = maxSize
    this.cache = new Map()
  }

  /**
   * Добавляет элемент в кэш или обновляет его позицию, если элемент уже существует.
   * Элементы, добавленные или обновленные последними, считаются наиболее недавно использованными.
   * Если размер кэша превышает максимально допустимый, наименее недавно использованный элемент будет удален.
   * @param {string} key - Ключ элемента, который добавляется в кэш.
   */
  add(key: string) {
    if (this.cache.has(key)) {
      // Удаляем и добавляем заново, чтобы обновить позицию
      this.cache.delete(key)
    } else if (this.cache.size >= this.maxSize) {
      // Удаляем наименее недавно использованный элемент (первый в Map)
      const oldestKey = this.cache.keys().next().value
      this.cache.delete(oldestKey)
    }
    this.cache.set(key, true)
  }

  /**
   * Проверяет, содержится ли элемент в кэше. Не изменяет порядок элементов в кэше.
   * @param {string} key - Ключ элемента для проверки.
   * @returns {boolean} Возвращает true, если элемент существует в кэше, иначе false.
   */
  has(key: string): boolean {
    return this.cache.has(key)
  }
}

// Использование LruCache вместо Set для кэширования изображений
const imageCache = new LruCache(50)
